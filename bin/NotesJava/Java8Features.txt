Java 8 introduced several powerful features that make Java programming more functional, concise, and expressive. These features revolutionized how developers approach tasks like processing collections, working with functions, and handling optional values. Let's explore Java 8 Features and beyond!

1. Lambda Expressions
Lambda expressions allow you to write cleaner, more concise, and readable code by enabling functional-style programming. They provide a way to pass behavior as parameters to methods.

Syntax of Lambda Expression:
java
Copy
Edit
(parameters) -> expression
No parameters: () -> System.out.println("Hello");
One parameter: (x) -> x * x
Multiple parameters: (a, b) -> a + b
Example:
java
Copy
Edit
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Sarah", "Michael");
        
        // Using Lambda Expression to print all names
        names.forEach(name -> System.out.println(name));
    }
}
Explanation:

forEach method takes a lambda expression as an argument, which processes each item in the list.
The lambda expression name -> System.out.println(name) replaces the need for writing a full loop.
2. Functional Interfaces
A functional interface is an interface with exactly one abstract method. These interfaces are used primarily to represent a single behavior, typically used with lambda expressions. Functional interfaces can have default and static methods, but only one abstract method.

Java provides several built-in functional interfaces in the java.util.function package, such as:

Predicate: Represents a boolean-valued function (test()).
Function: Represents a function that accepts one argument and returns a result (apply()).
Consumer: Represents an operation that takes an argument and returns no result (accept()).
Supplier: Represents a function that provides a result (get()).
Example:
java
Copy
Edit
@FunctionalInterface
interface Calculator {
    int add(int a, int b);  // Single abstract method

    default void greet() {
        System.out.println("Hello!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Lambda Expression implementing Calculator interface
        Calculator calc = (a, b) -> a + b;
        
        System.out.println("Sum: " + calc.add(5, 3));  // Output: Sum: 8
        calc.greet();  // Output: Hello!
    }
}
Explanation:

The Calculator interface has one abstract method add() and a default method greet().
The add() method is implemented using a lambda expression.
3. Stream API
The Stream API enables functional-style operations on collections of data. It allows you to process data in a pipeline of transformations, making code more readable and expressive.

Streams are not data structures; they represent a sequence of elements and support operations like filtering, mapping, and reducing.
Streams are lazy, meaning operations are not executed until a terminal operation is invoked.
Stream Operations:
Intermediate operations: (e.g., filter(), map(), sorted()) return a new stream.
Terminal operations: (e.g., collect(), forEach(), reduce()) trigger the processing of the stream and produce a result.
Example:
java
Copy
Edit
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Using Stream API to filter even numbers and calculate their sum
        int sum = numbers.stream()
                          .filter(n -> n % 2 == 0)  // Filter even numbers
                          .mapToInt(Integer::intValue)  // Convert Integer to int
                          .sum();  // Terminal operation: sum the values

        System.out.println("Sum of even numbers: " + sum);  // Output: 6
    }
}
Explanation:

The stream() method converts the list into a stream.
filter() filters even numbers, and mapToInt() converts the integers to primitive int.
sum() is a terminal operation that computes the sum of the elements.
4. Default and Static Methods in Interfaces
In Java 8, interfaces can have default methods and static methods.

Default Methods:
A default method has a body and can be implemented in the interface itself. This helps avoid breaking existing code when adding new methods to an interface.

Static Methods:
Static methods in interfaces can be called directly using the interface name, without needing an instance.

Example:
java
Copy
Edit
interface MyInterface {
    default void greet() {
        System.out.println("Hello from default method!");
    }
    
    static void staticMethod() {
        System.out.println("Hello from static method!");
    }
}

public class Main {
    public static void main(String[] args) {
        MyInterface.staticMethod();  // Calling static method
        MyInterface obj = new MyInterface() {};  // Creating an anonymous class
        obj.greet();  // Calling default method
    }
}
Explanation:

greet() is a default method, so it can be used directly without overriding.
staticMethod() is a static method, called via the interface.
5. Optional Class
The Optional class was introduced to represent a value that may or may not be present. It helps avoid NullPointerException by providing a container object which either contains a value or is empty.

Common Methods of Optional:
of(): Creates an Optional with a value.
empty(): Creates an empty Optional.
isPresent(): Checks if the Optional contains a value.
ifPresent(): Executes a block of code if a value is present.
orElse(): Returns a default value if the Optional is empty.
Example:
java
Copy
Edit
import java.util.Optional;

public class Main {
    public static void main(String[] args) {
        Optional<String> optionalName = Optional.ofNullable(null);  // Empty Optional

        optionalName.ifPresent(name -> System.out.println("Name is: " + name));
        String result = optionalName.orElse("Default Name");
        System.out.println("Result: " + result);  // Output: Default Name
    }
}
Explanation:

Optional.ofNullable(null) creates an empty Optional.
ifPresent() is used to execute code only if a value is present.
orElse() provides a default value if the Optional is empty.
6. New Date and Time API (java.time)
Java 8 introduced a new Date and Time API (java.time package) to handle dates, times, and durations more reliably and concisely. The new API is based on the ISO-8601 standard and provides several important classes:

LocalDate: Represents a date without time.
LocalTime: Represents a time without a date.
LocalDateTime: Represents a date and time.
ZonedDateTime: Represents a date and time with timezone information.
Duration and Period: Represent amounts of time.
Example: Working with LocalDate and LocalDateTime:
java
Copy
Edit
import java.time.*;

public class Main {
    public static void main(String[] args) {
        // Current date and time
        LocalDate today = LocalDate.now();
        LocalDateTime now = LocalDateTime.now();

        System.out.println("Today's Date: " + today);
        System.out.println("Current Date and Time: " + now);

        // Adding time
        LocalDateTime futureDate = now.plusDays(10).plusHours(5);
        System.out.println("Future Date and Time: " + futureDate);

        // Parsing a date
        LocalDate parsedDate = LocalDate.parse("2025-05-20");
        System.out.println("Parsed Date: " + parsedDate);
    }
}
Explanation:

LocalDate.now() gets the current date.
LocalDateTime.now() gets the current date and time.
plusDays() and plusHours() are used to add time.
LocalDate.parse() parses a date from a string.
Summary of Key Java 8 Features:
Lambda Expressions: Provide a concise way to write functions and pass behavior as parameters.
Functional Interfaces: Interfaces with a single abstract method, often used with lambda expressions.
Stream API: A powerful API for processing sequences of elements, enabling functional-style operations.
Default and Static Methods in Interfaces: Interfaces can have methods with a body, helping avoid breaking existing code.
Optional Class: A container for optional values, helping to prevent NullPointerException.
New Date and Time API: A more reliable and flexible API for handling dates, times, and durations.